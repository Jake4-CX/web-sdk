{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Carrot Web Software Development Kit","text":""},{"location":"#powered-by-carrotrgs","title":"Powered by CarrotRGS","text":"<p>Welcome to the Carrot-Web-SDK!</p> <p>The frontend-sdk is a PixieJS/Svelte package used for developing web-based slot games. This package walks though how to utilize powerful tools such as Turborepo and Storybook to test and publish slot games. Sample slot games are provided which consume outputs provided by the math-sdk, though the repo is customizable and can be tailored to accommodate custom events for slot games covering all levels of complexity.</p>"},{"location":"fe_readme/","title":"Web SDK","text":"<p>This is a web game engine that allows you developing a game in a declarative way. It is powered by Svelte 5, PixiJS 8 and TurboRepo.</p> <ul> <li>How to use: Fork or start your own codebase with this repo and changing any source code as you need.</li> </ul>"},{"location":"fe_readme/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Dependencies</li> <li>Get Started</li> <li>Explore Storybook</li> <li>Flow Chart</li> <li>playBookEvents()</li> <li>bookEvent</li> <li>bookEventHandlerMap</li> <li>eventEmitter</li> <li>emitterEvent</li> <li>emitterEventHandlerMap</li> <li>Task Breakdown</li> <li>Steps to Add a New BookEvent</li> <li>File Structure</li> <li>/apps</li> <li>/packages</li> <li>Context</li> <li>ContextEventEmitter</li> <li>ContextLayout</li> <li>ContextXstate</li> <li>ContextApp</li> <li>UI</li> <li>Internationalisation</li> </ul>"},{"location":"fe_readme/#dependencies","title":"Dependencies","text":"<p>Besides basic web skills (html, css and javascript), here it shows a list of npm dependencies of this repo. It would be great to start with understanding them before kicking off Get Started.</p> <ul> <li>pixijs: https://www.npmjs.com/package/pixi.js and more...</li> <li>svelte: https://www.npmjs.com/package/svelte and more...</li> <li>turborepo: https://www.npmjs.com/package/turbo and more...</li> <li>pixi-svelte: https://www.npmjs.com/package/pixi-svelte and more...</li> <li>This is an in-house npm package. It combines pixi and svelte together and uses pixijs in a declarative way.</li> <li>sveltekit: https://www.npmjs.com/package/@sveltejs/kit and more...</li> <li>storybook: https://www.npmjs.com/package/storybook and more...</li> <li>xstate: https://www.npmjs.com/package/xstate and more...</li> <li>typescript: https://www.npmjs.com/package/typescript and more...</li> <li>pnpm: https://www.npmjs.com/package/pnpm and more...</li> </ul> <p></p>"},{"location":"fe_readme/#get-started","title":"Get started","text":"<p>Here is a complete tutorial to start our sample games in the storybook. Please ignore those steps that you already know or done.</p> <ul> <li>It is preferred to use VS Code as IDE. download</li> <li>Install node with version 18.18.0. download</li> </ul> <pre><code># Download and install nvm:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\n\n# in lieu of restarting the shell\n\\. \"$HOME/.nvm/nvm.sh\"\n\n# Download and install Node.js:\nnvm install 18.18.0\n\n# Verify the node versions. Should print \"v18.18.0\".\nnode -v\n</code></pre> <ul> <li>Install pnpm with version 10.5.0.</li> </ul> <pre><code># Install pnpm\nnpm install pnpm@10.5.0 -g\n\n# Verify the pnpm versions. Should print \"v10.5.0\"\npnpm -v\n</code></pre> <ul> <li>Clone the repo to your local in VS Code terminal or others.</li> </ul> <pre><code>git clone &lt;REPO_CLONE_URL&gt;\ncd web-sdk\n</code></pre> <ul> <li>Install dependencies.</li> </ul> <pre><code>pnpm install\n</code></pre> <ul> <li>Run <code>pnpm run storybook --filter=&lt;MODULE_NAME&gt;</code> in the terminal to see the storybook of a sample game in a TurboRepo way. <code>&lt;MODULE_NAME&gt;</code> is the name in the package.json file of a module in apps or packages folders.</li> <li>For example, we have <code>\"name\": \"lines\"</code> in the apps/lines/package.json, so we can find it and run its storybook by:</li> </ul> <pre><code>pnpm run storybook --filter=lines\n</code></pre> <ul> <li>You should see this: </li> </ul>"},{"location":"fe_readme/#_1","title":"Web SDK","text":"<ul> <li>Now switch to <code>MODE_BASE/book/random</code> in the left sidebar, you will see an <code>Action</code> button appear on the left right conner of the game.</li> </ul>"},{"location":"fe_readme/#_2","title":"Web SDK","text":"<ul> <li>Click on the <code>Action</code> button and wait for a base game to finish.</li> <li>Congratulations! You are now in the zone of game development with us now.</li> </ul>"},{"location":"fe_readme/#explore-storybook","title":"Explore Storybook","text":"<p>Storybook is a powerful and handy tool to test our games. For example:</p> <ul> <li><code>COMPONENTS/&lt;Game&gt;/component</code>: It tests the  component. In this case, it doesn't skip the loading screen.</li> <li><code>COMPONENTS/&lt;Game&gt;/preSpin</code>: It tests the  component with the preSpin function.</li> <li><code>COMPONENTS/&lt;Game&gt;/emitterEvent</code>: It tests the  component with an emitterEvent \"boardHide\".</li> <li>...</li> <li><code>COMPONENTS/&lt;Symbol&gt;/component</code>: It tests the  component with controls e.g. state of the symbol.</li> <li><code>COMPONENTS/&lt;Symbol&gt;/symbols</code>: It tests the  component with all the symbols and all the states.</li> <li>...</li> <li><code>MODE_BASE/book/random</code>: It tests the  component with a random book of base mode.</li> <li><code>MODE_BASE/bookEvent/reveal</code>: It tests the  component with a \"reveal\" bookEvent of the base mode. It will spin the reels.</li> <li>...</li> <li><code>MODE_BONUS/book/random</code>: It tests the  component with a random book of bonus mode.</li> <li><code>MODE_BONUS/bookEvent/reveal</code>: It tests the  component with a \"reveal\" bookEvent of the bonus mode. It will spin the reels.</li> <li>...</li> </ul> <p> </p>"},{"location":"fe_readme/#_3","title":"Web SDK","text":"<p>With all the stories above and the stories that created and customised by yourself, we are able to test the whole game, intermediate components and atomic components.</p> <p>We are also able to test our game with a book, a sequence of bookEvents and a single bookEvent. If each bookEvent is implemented well with emitterEvents and its story is resolved properly, the game is technically finished.</p> <p></p>"},{"location":"fe_readme/#flow-chart","title":"Flow Chart","text":"<p>Here it is a simplified flow chart of steps how a game is processed after RGS request. The real situation might be more complicated, but it follows the same idea.</p> <p></p> <p></p>"},{"location":"fe_readme/#playbookevents","title":"playBookEvents()","text":"<p>This function is created by packages/utils-book/src/createPlayBookUtils.ts. It goes through bookEvents one by one, handles each one with async function <code>playBookEvent()</code>. It resolves them one after another with <code>sequence()</code> in the order of the bookEvents array. It means the sequence of bookEvents matters eminently and it determines the behaviors of the game. For example, we don't want to see the \"win\" before \"spin\", so we should put \"win\" after the \"spin\". This function is also used in the <code>MODE_&lt;GAME_MODE&gt;/book/random</code> stories.</p> <ul> <li> <p><code>playBookEvent()</code>: This is a function that takes in a bookEvent with some context (usually all the bookEvents), then find the bookEventHandler in bookEventHandlerMap based on <code>bookEvent.type</code> to process it. This function is also used in the <code>MODE_&lt;GAME_MODE&gt;/bookEvent/&lt;BOOK_EVENT_TYPE&gt;</code> stories.</p> </li> <li> <p><code>sequence()</code>: This is an async function to achieve resolving async functions/promises one after another. On the contrast, <code>Promise.all()</code> will trigger all the async functions/promises together at the same time, which is not what we desire for the sequence of the game.</p> </li> </ul> <p></p>"},{"location":"fe_readme/#bookevent","title":"bookEvent","text":"<ul> <li><code>book</code>: A book is a json data that is returned from the RGS (Remote Game Server) for each game requested. It is randomly picked from over a million of books, which is math. It is mainly composed by bookEvents.</li> </ul> <pre><code>// base_books.ts - Example of a base game book\n\n{\n  id: 1,\n  payoutMultiplier: 0.0,\n  events: [\n    {\n      index: 0,\n      type: 'reveal',\n      board: [\n        [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n        [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n        [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n        [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n        [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n      ],\n      paddingPositions: [216, 205, 195, 16, 65],\n      gameType: 'basegame',\n      anticipation: [0, 0, 0, 0, 0],\n    },\n    { index: 1, type: 'setTotalWin', amount: 0 },\n    { index: 2, type: 'finalWin', amount: 0 },\n  ],\n  criteria: '0',\n  baseGameWins: 0.0,\n  freeGameWins: 0.0,\n}\n</code></pre> <ul> <li><code>bookEvent</code>: A bookEvent is a json data that is one of the element of the <code>book.events</code> array.</li> </ul> <pre><code>// base_books.ts - Example of a \"reveal\" bookEvent\n\n{\n  index: 0,\n  type: 'reveal',\n  board: [\n    [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n    [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n    [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n    [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n    [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n  ],\n  paddingPositions: [216, 205, 195, 16, 65],\n  gameType: 'basegame',\n  anticipation: [0, 0, 0, 0, 0],\n}\n\n// base_books.ts - Example of a setTotalWin bookEvent\n\n{ index: 1, type: 'setTotalWin', amount: 0 },\n</code></pre> <ul> <li><code>bookEventHandler</code>: An async function that takes in a bookEvent and do some operations with it. Usually it broadcasts some emitterEvents, so the components will receive and handle.</li> </ul>"},{"location":"fe_readme/#bookeventhandlermap","title":"bookEventHandlerMap","text":"<p>An object that the key is <code>bookEvent.type</code> and value is a <code>bookEventHandler</code>. We can find an example in apps/lines/src/game/bookEventHandlerMap.ts.</p> <pre><code>// bookEventHandlerMap.ts - Example of \"updateFreeSpin\" bookEventHandler\n\nexport const bookEventHandlerMap: BookEventHandlerMap&lt;BookEvent, BookEventContext&gt; = {\n  ...,\n  updateFreeSpin: async (bookEvent: BookEventOfType&lt;'updateFreeSpin'&gt;) =&gt; {\n    eventEmitter.broadcast({ type: 'freeSpinCounterShow' });\n    eventEmitter.broadcast({\n      type: 'freeSpinCounterUpdate',\n      current: bookEvent.amount,\n      total: bookEvent.total,\n    });\n  },\n  ...,\n}\n</code></pre> <ul> <li>In simple terms, a book is composed by multiple bookEvents. Different combinations of bookEvents will determine the different behaviours of a game e.g. win/lose, a big/small win, a base/bonus game, 1/10/15 spins and so on.</li> </ul> <p></p>"},{"location":"fe_readme/#eventemitter","title":"eventEmitter","text":"<p>It achieves event-driven programming for the development. It can either broadcast or subscribe to emitterEvents. It connects the javascript scope and svelte component scope with emitterEvents instead of passing the different states as svelte component props directly. The three most used functions are:</p> <ul> <li><code>eventEmitter.broadcast()</code></li> <li><code>eventEmitter.broadcastAsync()</code></li> <li><code>eventEmitter.subscribeOnMount()</code></li> </ul> <p></p>"},{"location":"fe_readme/#emitterevent","title":"emitterEvent","text":"<p>An emitterEvent is a json data that <code>eventEmitter.broadcast(emitterEvent)</code> or <code>eventEmitter.broadcastAsync(emitterEvent)</code> broadcasts, so that a component which has <code>eventEmitter.subscribeOnMount(emitterEventHandlerMap)</code> can receive the data and deal with it in a synchronous or asynchronous way.</p> <p>For a game we have many animations, so sometimes we need to \"await\" for those animations to finish before going to the next step.</p> <p>Conceptually a bookEvent is composed by emitterEvents. Nevertheless, the flexibility lies in that the emitterEvents composing a bookEvent can come from multiple different svelte components. This way we can achieve and control the interactions and timing between different svelte components for the same bookEvent, ultimately, to achieve our games.</p> <pre><code>// bookEventHandlerMap.ts - Example of an emitterEvent\n\n{\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n}\n</code></pre> <ul> <li><code>EmitterEventHandler (Synchronous)</code>: A sync function that takes in an emitterEvent. It usually deals with some sync operations e.g. show/hide component, tidy up, update some numbers and so on.</li> </ul> <pre><code>// bookEventHandlerMap.ts - Example of broadcast\n\neventEmitter.broadcast({\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n});\n\n// FreeSpinCounter.svelte - Example of receiving\n\ncontext.eventEmitter.subscribeOnMount({\n  ...,\n  freeSpinCounterUpdate: (emitterEvent) =&gt; {\n    if (emitterEvent.current !== undefined) current = emitterEvent.current;\n    if (emitterEvent.total !== undefined) total = emitterEvent.total;\n  },\n  ...,\n});\n</code></pre> <ul> <li><code>EmitterEventHandler (Asynchronous)</code>: An async function that takes in an emitterEvent. It usually deals with some async operations e.g. wait for fading in/out component, wait for animations to finish, wait for numbers to increase/decrease with svelte-tween and so on.</li> </ul> <pre><code>// bookEventHandlerMap.ts - Example of broadcastAsync\n\nawait eventEmitter.broadcastAsync({\n  type: 'freeSpinIntroUpdate',\n  totalFreeSpins: bookEvent.totalFs,\n});\n\n// FreeSpinIntro.svelte - Example of receiving\n\ncontext.eventEmitter.subscribeOnMount({\n  ...,\n  freeSpinIntroUpdate: async (emitterEvent) =&gt; {\n    freeSpinsFromEvent = emitterEvent.totalFreeSpins;\n    await waitForResolve((resolve) =&gt; (oncomplete = resolve));\n  },\n  ...,\n});\n</code></pre> <p></p>"},{"location":"fe_readme/#emittereventhandlermap","title":"emitterEventHandlerMap","text":"<p>An object that the key is <code>emitterEvent.type</code> and value is an <code>emitterEventHandler</code>. We can find this object in each component. For example, apps/lines/src/components/FreeSpinCounter.svelte.</p> <ul> <li>Each emitterEventHandler can do a lot or a little, but we prefer each emitterEventHandler just doing a minimum job to achieve the duty that is described by its type. This way we follow the Single Responsibility Principle of SOLID. For example, <code>freeSpinCounterShow</code> just shows this component and does nothing more.</li> </ul> <pre><code>// FreeSpinCounter.svelte and its emitterEventHandlers\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventFreeSpinCounter =\n    | { type: 'freeSpinCounterShow' }\n    | { type: 'freeSpinCounterHide' }\n    | { type: 'freeSpinCounterUpdate'; current?: number; total?: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.eventEmitter.subscribeOnMount({\n    freeSpinCounterShow: () =&gt; (show = true),\n    freeSpinCounterHide: () =&gt; (show = false),\n    freeSpinCounterUpdate: (emitterEvent) =&gt; {\n      if (emitterEvent.current !== undefined) current = emitterEvent.current;\n      if (emitterEvent.total !== undefined) total = emitterEvent.total;\n    },\n  });\n&lt;/script&gt;\n\n&lt;MainContainer&gt;\n  ...\n&lt;/MainContainer&gt;\n</code></pre> <p></p>"},{"location":"fe_readme/#task-breakdown","title":"Task Breakdown","text":"<p>There is one single idea that is been applied across the whole carrot-game-sdk that is Task Breakdown.</p> <p>To extend a bit more of the topic above, if an emitterEventHandler does too much work, then it is better we consider to split it into smaller emitterEventHandlers as a process of task-breakdown.</p> <p>For example, \"tumbleBoard\" bookEvent is a fairly complicated bookEvent. Instead of having one \"tumbleBoard\" emitterEvent, we split it into \"tumbleBoardInit\", \"tumbleBoardExplode\", \"tumbleBoardRemoveExploded\", \"tumbleBoardSlideDown\".</p> <p>This way we can implement a big and complicated emitterEvent step by step. More importantly, we can test the implementations one by one in storybook of <code>COMPONENTS/&lt;Game&gt;/emitterEvent</code>.</p> <pre><code>// bookEventHandlerMap.ts - Example of task-breakdown\n\n{\n  ...,\n  tumbleBoard: async (bookEvent: BookEventOfType&lt;'tumbleBoard'&gt;) =&gt; {\n    eventEmitter.broadcast({ type: 'tumbleBoardShow' });\n    eventEmitter.broadcast({ type: 'tumbleBoardInit', addingBoard: bookEvent.newSymbols });\n    await eventEmitter.broadcastAsync({\n      type: 'tumbleBoardExplode',\n      explodingPositions: bookEvent.explodingSymbols,\n    });\n    eventEmitter.broadcast({ type: 'tumbleBoardRemoveExploded' });\n    await eventEmitter.broadcastAsync({ type: 'tumbleBoardSlideDown' });\n    eventEmitter.broadcast({\n      type: 'boardSettle',\n      board: stateGameDerived\n        .tumbleBoardCombined()\n        .map((tumbleReel) =&gt; tumbleReel.map((tumbleSymbol) =&gt; tumbleSymbol.rawSymbol)),\n    });\n    eventEmitter.broadcast({ type: 'tumbleBoardReset' });\n    eventEmitter.broadcast({ type: 'tumbleBoardHide' });\n  },\n  ...,\n}\n</code></pre> <pre><code>// TumbleBoard.svelte - Example of task-breakdown\n\ncontext.eventEmitter.subscribeOnMount({\n  tumbleBoardShow: () =&gt; {},\n  tumbleBoardHide: () =&gt; {},\n  tumbleBoardInit: () =&gt; {},\n  tumbleBoardReset: () =&gt; {},\n  tumbleBoardExplode: () =&gt; {},\n  tumbleBoardRemoveExploded: () =&gt; {},\n  tumbleBoardSlideDown: () =&gt; {},\n});\n</code></pre> <p>Stateless games can be complicated as well (vs. stateful games). For example, a slots game can have different types of spins, number of spins, win rules, number of bookEvents, game modes, global multiplier, multiplier symbols and so on.</p> <ul> <li>Stateless games: A single request to the RGS will finish the job of playing a game. For example, it requires only one request to play and finish a slots game.</li> <li>Stateful games: It requires multiple requests to the RGS to be able to finish the job. For example, a mines game.</li> </ul> <p></p> <p>However with the data structure of math and the functions we have, we are able to break down a complicated game into small and atomic tasks (emitterEvents). It enables us to test the atomics independently as well. Visually it is something like this:</p> <p></p> <p>The colors of the emitterEvents under a bookEvent can be different, which means they are from different svelte components.</p> <p></p>"},{"location":"fe_readme/#steps-to-add-a-new-bookevent","title":"Steps to Add a New BookEvent","text":"<p>For example, we have a game apps/lines already. Assume that we have added a new bookEvent <code>updateGlobalMult</code> to the bonus game mode (<code>MODE_BONUS</code>) in math, so that we have a new global multiplier feature for the game. Based on that, here we will go through the steps together to implement this new bookEvent and add it to the game. Along the way we will introduce part of our file structure as well.</p> <ul> <li>apps/lines/src/stories/data/bonus_books.ts: This file includes the an array of bonus books that story <code>MODE_BONUS/book/random</code> will randomly pick at. This is to simulate requesting data from RGS. All we need to do is to copy/paste data from our new math package and format it.</li> </ul> <pre><code>// bonus_books.ts\n\n{\n  type: 'updateGlobalMult',\n  globalMult: 3,\n},\n</code></pre> <ul> <li>apps/lines/src/stories/data/bonus_events.ts: This file includes the an object of every type of bookEvent that story <code>MODE_BONUS/bookEvent/&lt;BOOK_EVENT_TYPE&gt;</code> uses. All we need to do is to copy/paste data from our new math package and format it.</li> </ul> <pre><code>// bonus_events.ts\n\nexport default {\n  ...,\n  updateGlobalMult: {\n    type: 'updateGlobalMult',\n    globalMult: 3,\n  },\n  ...,\n}\n</code></pre> <ul> <li>apps/lines/src/stories/ModeBonusBookEvent.stories.svelte: This file implements all the sub stories in story set <code>MODE_BONUS/bookEvent</code>. With the following code added in this file, you will see the a new story <code>MODE_BONUS/bookEvent/updateGlobalMult</code> that is added in our storybook with an <code>Action</code> button. Now if we click on it and nothing would happen, but it is a good start because we set up the testing environment first. Next step is to add code of bookEventHandler to handle it.</li> </ul> <pre><code>// ModeBonusBookEvent.stories.svelte\n\n&lt;Story\n  name=\"updateGlobalMult\"\n  args={templateArgs({\n    skipLoadingScreen: true,\n    data: events.updateGlobalMult,\n    action: async (data) =&gt; await playBookEvent(data, { bookEvents: [] }),\n  })}\n/&gt;\n</code></pre> <ul> <li>apps/lines/src/game/typesBookEvent.ts: This file contains typescript types of all the bookEvents. Let is add the type of our new bookEvent to get the intellisense from typescript for the following step.</li> <li><code>type BookEvent</code> is a union type (typescript union type) of BookEvent types.</li> </ul> <pre><code>// typesBookEvent.ts\n\ntype BookEventUpdateGlobalMult = {\n  index: number;\n  type: 'updateGlobalMult';\n  globalMult: number;\n};\n\nexport type BookEvent =\n  | ...\n  | BookEventUpdateGlobalMult\n  | ...\n;\n</code></pre> <ul> <li>apps/lines/src/game/bookEventHandlerMap.ts: This file includes all the bookEventHandlers. Let is add a new one for the new bookEvent. Check the intellisense that the previous step brings, it provides a better developer experience.</li> </ul> <p></p>"},{"location":"fe_readme/#_4","title":"Web SDK","text":"<ul> <li>apps/lines/src/components/GlobalMultiplier.svelte: This file is created as our target svelte component for updateGlobalMulti bookEvent. Technically speaking, all the jobs that is related to global multiplier of the game should only be in this svelte component. Similar to the bookEvent types, let is add the typescript types for new emitterEvents first.</li> <li><code>type EmitterEventGlobalMultiplier</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// GlobalMultiplier.svelte\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventGlobalMultiplier =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n</code></pre> <ul> <li>apps/lines/src/game/typesEmitterEvent.ts: This file has typescript types of all the emitterEvents of the game. Let is add the type of our new emitterEvents for intellisense.</li> <li><code>type EmitterEventGame</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// typesEmitterEvent.ts\n\n...\nimport type { EmitterEventGlobalMultiplier } from '../components/GlobalMultiplier.svelte';\n...\n\nexport type EmitterEventGame =\n  | ...\n  | EmitterEventGlobalMultiplier\n  | ...\n;\n</code></pre> <ul> <li>apps/lines/src/game/eventEmitter.ts: This file exports the eventEmitter, it uses the <code>EmitterEventGame</code> and other EmitterEvent types to compose <code>type EmitterEvent</code>.</li> <li><code>type EmitterEvent</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// eventEmitter.ts\n\n...\nimport type { EmitterEventGame } from './typesEmitterEvent';\nexport type EmitterEvent = EmitterEventUi | EmitterEventHotKey | EmitterEventGame;\nexport const { eventEmitter } = createEventEmitter&lt;EmitterEvent&gt;();\n\n</code></pre> <ul> <li>apps/lines/src/components/GlobalMultiplier.svelte: Back to our component file, the intellisense is there. Let is add the code to process the values with a spine animation as well.</li> </ul>"},{"location":"fe_readme/#_5","title":"Web SDK","text":"<pre><code>// GlobalMultiplier.svelte\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventGlobalMultiplier =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.eventEmitter.subscribeOnMount({\n    globalMultiplierShow: () =&gt; (show = true),\n    globalMultiplierHide: () =&gt; (show = false),\n    globalMultiplierUpdate: async (emitterEvent) =&gt; {\n      console.log(emitterEvent.multiplier)\n    },\n  });\n&lt;/script&gt;\n\n&lt;SpineProvider key=\"globalMultiplier\" width={PANEL_WIDTH}&gt;\n  ...\n  &lt;SpineTrack trackIndex={0} {animationName} /&gt;\n&lt;/SpineProvider&gt;\n</code></pre> <ul> <li> <p>Test it individually <code>(MODE_BONUS/bookEvent/updateGlobalMult)</code>: Run storybook and we should see this a new story \"updateGlobalMult\" has been added.</p> </li> <li> <p>Now click on the <code>Action</code> button and we should see the  component animates correctly followed by the \" \u24d8 Action is resolved \u2705 \" message, otherwise we need to go back to the component and figure out what is wrong until it is resolved.</p> </li> <li> <p>If you find out the component hard to debug, we'd better start creating a new story <code>COMPONENTS/&lt;GlobalMultiplierSpine&gt;/component</code>. <code>&lt;GlobalMultiplierSpine /&gt;</code> component will purely take props and achieve its duty instead of being controlled by emitterEvents. This way it becomes more friendly for testing the component with the storybook controls.</p> </li> <li> <p>Test it in books <code>(MODE_BONUS/book/random)</code>: Final step is to test it in a book environment by switching to this book story. In a previous step we have updated apps/lines/src/stories/data/bonus_books.ts, so the new bookEvent will appear if we keep hitting the <code>Action</code> button in this story.</p> </li> </ul> <p></p>"},{"location":"fe_readme/#file-structure","title":"File Structure","text":"<p>The file structure is in a way of structure of TurboRepo to achieve a monorepo. Besides the files for the configurations of TurboRepo, sveltekit, eslint, typescript, git and so on, here is a list of of key modules of apps and packages.</p> <pre><code>root\n  |_apps\n  |  |_cluster\n  |  |_lines\n  |  |_price\n  |  |_scatter\n  |  |_ways\n  |\n  |_packages\n     |_config-*\n     |_constants-*\n     |_state-*\n     |_utils-*\n     |_components-*\n     |_pixi-*\n</code></pre> <p></p>"},{"location":"fe_readme/#apps","title":"/apps","text":"<p>For each game, it has an individual folder in the apps, for example apps/lines.</p> <ul> <li>apps/lines/package.json: Find the module name of the app here.</li> </ul> <pre><code>{\n  \"name\": \"lines\",\n  ...\n}\n</code></pre> <ul> <li>To run the app in DEV mode instead of in the storybook: Run <code>pnpm run dev --filter=&lt;MODULE_NAME&gt;</code> in the terminal.</li> </ul> <pre><code>pnpm run dev --filter=lines\n</code></pre> <ul> <li>apps/lines/src/routes/+page.svelte: This is the entry file of sample game apps/lines in a sveltekit way. It is a combination of two things:</li> <li>setContext(): A function that sets all the svelte-context required and used in this app and in the packages. As we already know, only children-level components can access the context. That is why we set the context at the entry level of the app.</li> <li>: The entry svelte component to the game. It includes all the components of the game.</li> </ul> <pre><code>// +page.svelte\n\n&lt;script lang=\"ts\"&gt;\n  import Game from '../components/Game.svelte';\n  import { setContext } from '../game/context';\n\n  setContext();\n&lt;/script&gt;\n\n&lt;Game /&gt;\n</code></pre> <ul> <li>apps/lines/src/stories/ComponentsGame.stories.svelte: You will find the same pattern in this storybook or other <code>Mode&lt;GAME_MODE&gt;Book.stories.svelte</code> and <code>Mode&lt;GAME_MODE&gt;BookEvent.stories.svelte</code>.</li> </ul> <pre><code>// ComponentsGame.stories.svelte\n\n&lt;script lang=\"ts\"&gt;\n  ...\n  import Game from '../components/Game.svelte';\n  import { setContext } from '../game/context';\n\n  ...\n  setContext();\n&lt;/script&gt;\n\n&lt;Story name=\"component (loadingScreen)\"&gt;\n  &lt;StoryLocale lang=\"en\"&gt;\n    &lt;Game /&gt;\n  &lt;/StoryLocale&gt;\n&lt;/Story&gt;\n</code></pre> <ul> <li>We can render  component in the app or in the storybook. Either way it requires the context to set in advance, otherwise the children or the descendants will throw errors if they use the \"getContext()\" from apps or \"getContext()\" from packages.</li> </ul> <p></p>"},{"location":"fe_readme/#packages","title":"/packages","text":"<p>For every TurboRepo local package, you can import and use them in an app or in another local package directly without publishing them to npm. Our codebase benefits considerably from a monorepo because it brings reusability, readability, maintainability, code splitting and so on. Here is an example of importing local packages with <code>workspace:*</code> in apps/lines/package.json:</p> <pre><code>// package.json\n\n{\n  \"name\": \"lines\",\n  ...,\n  \"devDependencies\": {\n    ...,\n    \"config-ts\": \"workspace:*\",\n  },\n  \"dependencies\": {\n    ...,\n    \"pixi-svelte\": \"workspace:*\",\n    \"constants-shared\": \"workspace:*\",\n    \"state-shared\": \"workspace:*\",\n    \"utils-shared\": \"workspace:*\",\n    \"components-shared\": \"workspace:*\",\n  }\n}\n</code></pre> <p>The naming convention of packages is a combination of <code>&lt;PACKAGE_TYPE&gt;</code>, hyphen and <code>&lt;SPECIAL_DEPENDENCY&gt;</code> or <code>&lt;SPECIAL_USAGE&gt;</code>. For example, <code>components-pixi</code> is a local package that the package type is \"components\" and the special dependency is <code>pixi-svelte</code>.</p> <ul> <li><code>config-*</code>:</li> <li>config-lingui: This local package contains reusable configurations of npm package lingui.</li> <li>config-storybook: This local package contains reusable configurations of npm package storybook.</li> <li>config-svelte: This local package contains reusable configurations of npm package svelte.</li> <li>config-ts: This local package contains reusable configurations of npm package typescript.</li> <li>config-vite: This local package contains reusable configurations of npm package vite.</li> <li><code>pixi-*</code></li> <li>pixi-svelte: This local package contains reusable svelte components/functions/types based on pixijs and svelte.<ul> <li>It creates <code>stateApp</code> and <code>AppContext</code> as a svelte-context.</li> <li>It also builds and publishes pixi-svelte of npm.</li> </ul> </li> <li>pixi-svelte-storybook: This is a storybook for components in <code>pixi-svelte</code>.</li> <li><code>constants-*</code>:</li> <li>constants-shared: This local package contains reusable global constants.</li> <li><code>state-*</code>:</li> <li>state-shared: This local package contains reusable global svelte-$state.</li> <li><code>utils-*</code>:</li> <li>utils-book: This local package contains reusable functions/types that are related to book and bookEvent.</li> <li>utils-fetcher: This local package contains reusable functions/types based on fetch API.</li> <li>utils-shared: This local package contains reusable functions/types, except for lodash and lingui.</li> <li>utils-slots: This local package contains reusable functions/types for slots game, for example creating reel and spinning the board.</li> <li>utils-sound: This local package contains reusable functions/types based on npm package howler for music and sound effect.</li> <li>utils-event-emitter: This local package contains reusable functions/types to achieve our event-driven programming.<ul> <li>It creates <code>eventEmitter</code> and <code>ContextEventEmitter</code> as a svelte-context</li> </ul> </li> <li>utils-xstate: This local package contains reusable functions/types based on npm package xstate.<ul> <li>It creates <code>stateXstate</code>, <code>stateXstateDerived</code> and <code>ContextXstate</code> as a svelte-context</li> </ul> </li> <li>utils-layout: This local package contains reusable functions/types for our layout system of pixijs.<ul> <li>It creates <code>stateLayout</code>, <code>stateLayoutDerived</code> and <code>ContextLayout</code> as a svelte-context</li> </ul> </li> <li><code>components-*</code>:</li> <li>components-layout: This local package contains reusable svelte components based on another local package <code>utils-layout</code>.</li> <li>components-pixi: This local package contains reusable svelte components based on <code>pixi-svelte</code>.</li> <li>components-shared: This local package contains reusable svelte components based on <code>html</code>.</li> <li>components-storybook: This local package contains reusable svelte components for storybooks.</li> <li>components-ui-pixi: This local package contains reusable svelte pixi-svelte components for the game UI.</li> <li>components-ui-html: This local package contains reusable svelte html components for the game UI.</li> </ul> <p>For <code>*-shared</code> packages, they are created to be reused as much as possible by other apps and packages. Instead of having a special dependency or usage, they should have a minimum list of dependencies and a broad set of use cases.</p> <p><code>pixi-svelte</code>, <code>utils-event-emitter</code>, <code>utils-layout</code> and <code>utils-xstate</code> they have functions to create corresponding svelte-context. For the contexts, they can be used by either an app or a local <code>components-*</code> package by just calling the <code>getContext&lt;CONTEXT_NAME&gt;()</code>. For example, components in <code>components-layout</code> use <code>getContextLayout()</code> from <code>utils-layout</code>. In this way, we can regard <code>pixi-svelte</code> as an integration of \"utils-pixi-svelte\" and \"components-pixi-svelte\".</p> <p></p>"},{"location":"fe_readme/#context","title":"Context","text":"<p>svelte-context is a useful feature from svelte especially when a shared state requires some inputs/types to create. Here it shows the structure of context of sample game apps/lines. As showed before, <code>setContext()</code> is called at entry level component. For example, apps/lines/src/routes/+page.svelte or apps/lines/src/stories/ComponentsGame.stories.svelte. It sets four major contexts from the packages by this:</p> <pre><code>// context.ts - Example of setContext in apps\n\nexport const setContext = () =&gt; {\n  setContextEventEmitter&lt;EmitterEvent&gt;({ eventEmitter });\n  setContextXstate({ stateXstate, stateXstateDerived });\n  setContextLayout({ stateLayout, stateLayoutDerived });\n  setContextApp({ stateApp });\n};\n</code></pre> <p>Different apps and packages require different contexts.</p> <p></p> <p></p>"},{"location":"fe_readme/#contexteventemitter","title":"ContextEventEmitter","text":"<p><code>eventEmitter</code> is created by packages/utils-event-emitter/src/createEventEmitter.ts. We have covered eventEmitter in the previous content.</p> <p></p>"},{"location":"fe_readme/#contextlayout","title":"ContextLayout","text":"<p><code>stateLayout</code> and <code>stateLayoutDerived</code> are created by packages/utils-layout/src/createLayout.svelte.ts. It provides canvasSizes, canvasRatio, layoutType and so on. Because we have a setting <code>resizeTo: window</code> for PIXI.Application, we use the sizes of window from svelte-reactivity as <code>canvasSizes</code>.</p> <p>For html, the tags will auto-flow by default. However, in the canvas/pixijs we need to set positions manually to avoid overlapping. The importance of LayoutContext is that it provides us the values of boundaries (canvasSizes), device type based on the dimensions (layoutType) and so on. For example:</p> <ul> <li>Set a pixi-svelte component to the left edge of the canvas:</li> <li><code>&lt;Component x={0} /&gt;</code></li> <li>Set a pixi-svelte component to the right edge of the canvas:</li> <li><code>&lt;Component x={context.stateLayoutDerived.canvasSizes().width} anchor={{ x: 1: y: 0 }} /&gt;</code></li> <li>It works when <code>&lt;App /&gt;</code> is the parent of the component, otherwise it will be determined by its parent <code>&lt;Container /&gt;</code>.</li> <li>The reason why we set <code>anchor</code> is because that the drawing is always go from top-left to bottom-right in pixijs.</li> </ul> <pre><code>// createLayout.svelte.ts\n\nimport { innerWidth, innerHeight } from 'svelte/reactivity/window';\n\n...\n\nconst stateLayout = $state({\n  showLoadingScreen: true,\n});\n\nconst stateLayoutDerived = {\n  canvasSizes,\n  canvasRatio,\n  canvasRatioType,\n  canvasSizeType,\n  layoutType,\n  isStacked,\n  mainLayout,\n  normalBackgroundLayout,\n  portraitBackgroundLayout,\n};\n</code></pre> <p></p>"},{"location":"fe_readme/#contextxstate","title":"ContextXstate","text":"<p><code>stateXstate</code> and <code>stateXstateDerived</code> are created by packages/utils-xstate/src/createXstateUtils.svelte.ts. It provides a few functions to check the state of finite state machine, also known as <code>gameActor</code>, which is created by packages/utils-xstate/src/createGameActor.svelte.ts.</p> <pre><code>// createXstateUtils.svelte.ts\n\nimport { matchesState, type StateValue } from 'xstate';\n\n...\n\nconst stateXstate = $state({\n  value: '' as StateValue,\n});\n\nconst matchesXstate = (state: string) =&gt; matchesState(state, stateXstate.value);\n\nconst stateXstateDerived = {\n  matchesXstate,\n  isRendering: () =&gt; matchesXstate(STATE_RENDERING),\n  isIdle: () =&gt; matchesXstate(STATE_IDLE),\n  isBetting: () =&gt; matchesXstate(STATE_BET),\n  isAutoBetting: () =&gt; matchesXstate(STATE_AUTOBET),\n  isResumingBet: () =&gt; matchesXstate(STATE_RESUME_BET),\n  isForcingResult: () =&gt; matchesXstate(STATE_FORCE_RESULT),\n  isPlaying: () =&gt; !matchesXstate(STATE_RENDERING) &amp;&amp; !matchesXstate(STATE_IDLE),\n};\n</code></pre> <p><code>gameActor</code>: To avoid using massive \"if-else\" conditions in the code, we use npm/xstate to create a finite state machine to handle the complicated logic and states of betting. It provides a few pre-defined mechanics like one-off <code>bet</code>, <code>autoBet</code> with a count down, <code>resumeBet</code> to continue an unfinished bet and so on.</p> <pre><code>// createGameActor.svelte.ts\n\nimport { setup, createActor } from 'xstate';\n\n...\n\nconst gameMachine = setup({\n  actors: {\n    bet: intermediateMachines.bet,\n    autoBet: intermediateMachines.autoBet,\n    resumeBet: intermediateMachines.resumeBet,\n    forceResult: intermediateMachines.forceResult,\n  },\n}).createMachine({\n  initial: 'rendering',\n  states: {\n    [STATE_RENDERING]: stateRendering,\n    [STATE_IDLE]: stateIdle,\n    [STATE_BET]: stateBet,\n    [STATE_AUTOBET]: stateAutoBet,\n    [STATE_RESUME_BET]: stateResumeBet,\n    [STATE_FORCE_RESULT]: stateForceResult,\n  },\n});\n\nconst gameActor = createActor(gameMachine);\n</code></pre> <p>This is highly useful when it comes to the interactions with UI, for example disable the bet button when the a game is playing.</p> <pre><code>// BetButton.svelte - Example of interaction between xstate and UI\n\n&lt;script lang=\"ts\"&gt;\n  import { getContext } from '../context';\n\n  const context = getContext();\n&lt;/script&gt;\n\n&lt;SimpleUiButton disabled={context.stateXstateDerived.isPlaying()} /&gt;\n</code></pre> <p></p>"},{"location":"fe_readme/#appcontext","title":"AppContext","text":"<p><code>stateApp</code> is created by packages/pixi-svelte/src/lib/createApp.svelte.ts. <code>loadedAssets</code> contains the static images, animations and sound data that is processed by <code>PIXI.Assets.load</code> with <code>stateApp.assets</code>. <code>loadedAssets</code> can be digested by pixi-svelte components directly as showed in pixi-svelte component \\&lt;Sprite /&gt;.</p> <pre><code>// createApp.svelte.ts\n\nconst stateApp = $state({\n  reset,\n  assets,\n  loaded: false,\n  loadingProgress: 0,\n  loadedAssets: {} as LoadedAssets,\n  pixiApplication: undefined as PIXI.Application | undefined,\n});\n</code></pre> <p></p>"},{"location":"fe_readme/#ui","title":"UI","text":"<p>We have provided solutions for the UI, which are components-ui-pixi and components-ui-html. They are functional with a few features like auto gaming, turbo mode, bonus button, responsiveness and so on, but they are not as beautiful.</p> <pre><code>&lt;script lang=\"ts\"&gt;\n    import { UI, UiGameName } from 'components-ui-pixi';\n    import { GameVersion, Modals } from 'components-ui-html';\n&lt;/script&gt;\n\n&lt;App&gt;\n  &lt;UI&gt;\n    {#snippet gameName()}\n      &lt;UiGameName name=\"LINES GAME\" /&gt;\n    {/snippet}\n    {#snippet logo()}\n      &lt;Text\n        anchor={{ x: 1, y: 0 }}\n        text=\"ADD YOUR LOGO\"\n        style={{\n          fontFamily: 'proxima-nova',\n          fontSize: REM * 1.5,\n          fontWeight: '600',\n          lineHeight: REM * 2,\n          fill: 0xffffff,\n        }}\n      /&gt;\n    {/snippet}\n  &lt;/UI&gt;\n&lt;/App&gt;\n\n&lt;Modals&gt;\n    {#snippet version()}\n        &lt;GameVersion version=\"0.0.0\" /&gt;\n    {/snippet}\n&lt;/Modals&gt;\n\n</code></pre> <p>For the branding purpose, we recommend you to regard them as just an example of UI packages instead of applying them directly to your final product. It would be a good choice to use them as a starting point and add more style to them to build your UI. It is completely fine to ignore them and build your own UI from scratch.</p> <p></p>"},{"location":"fe_readme/#internationalisation-i18n","title":"Internationalisation (i18n)","text":""}]}